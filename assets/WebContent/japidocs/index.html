<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>JAPIDOCS - Documentação da Framework</title>

    <!-- Bootstrap Core CSS -->
    <link href="css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom CSS -->
    <link href="css/simple-sidebar.css" rel="stylesheet">
    <link href="css/japidocs.css" rel="stylesheet">
    <link href="http://alexgorbatchev.com/pub/sh/current/styles/shThemeDefault.css" rel="stylesheet" type="text/css" />
    <link href="http://alexgorbatchev.com/pub/sh/current/styles/shCore.css" rel="stylesheet" type="text/css" />


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

</head>

<body>

    <div id="wrapper">

        <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="#">
                        Documentação JAPI
                    </a>
                </li>
                <li>
                    <a href="#reqs">Requisitos</a>
                </li>
                <li>
                    <a href="#configurando">Configurando o ambiente</a>
                </li>
                <li>
                    <a href="#modulos">Módulos</a>
                </li>
                <li class="submenu">
                    <a href="#primeiroModulo">Criando o primeiro módulo</a>
                </li>
                <li>
                    <a href="#camadas">As camadas</a>
                </li>
                <li class="submenu">
                    <a href="#request">Request</a>
                </li>
                <li class="submenu">
                    <a href="#resource">Resource</a>
                </li>
                <li class="submenu">
                    <a href="#service">Service</a>
                </li>
            </ul>
        </div>
        <!-- /#sidebar-wrapper -->

        <!-- Page Content -->
        <div id="page-content-wrapper">
            <div class="container-fluid">
                <div class="row">
                    <div class="col-lg-12">
                    	<div id="home">
                    		<h1>JAPI- Framework para desenvolvimento de API's do Governo</h1>
	                        <p>Utilize o menu ao lado para navegar entre os diferentes tutoriais</p>
	                        <a href="#menu-toggle" class="btn btn-default" id="menu-toggle">Toogle Menu</a>    	
                    	</div>
                    	<hr>
                    	<div id="reqs">
	                    	<h1>Requisitos de instalação:</h1>
							<ul>
								<li>Eclipse Luna</li>
								<li>Java 1.7.71+</li>
								<li>JBoss EAP 6.1+</li>
								<li>Gradle - recomendado o gradle IDE pack 3.6+ do eclipse</li>
								<li>Project Facets do Eclipse:</li>
								<ul>
									<li>Java</li>
									<li>Dynamic Web Module</li>
									<li>JAX-RS</li>
									<li>JAXB</li>
								</ul>
							</ul>
                    	</div>
                    	<hr>
                    	<div id="configurando">
                    		<h1>Configurando o ambiente</h1>
                    		<p>Em conjunto com a API, são baixados dois módulos: O de documentação (docs) e um de testes.</p>
                    		<p>Para seguirmos com o tutorial, configuraremos o funcionamento do módulo de testes, que será semelhante a qualquer novo módulo criado a partir deste.</p>
                    		<h3>1: Instalar e iniciar o JBoss no Eclipse</h3>
                    		<ul>
                    			<li>Fazer download do JBoss <a href="http://www.jboss.org/download-manager/file/jboss-eap-6.2.0.GA.zip">aqui.</a></li>
                    			<li>Extraia o JBOSS em alguma pasta de sua preferência.</li>
                    			<li>No Eclipse, ir em Help -> Eclipse Marketplace e pesquisar pelo JBoss Tools (Luna) 4.2.2.Final e instala-lo.</li>
                    			<li>Na aba Servers do Eclipse, na perspectiva Java EE, crie um novo servidor, clicando com o botão direito -> New -> Server.</li>
                    			<li>Na nova janela, escolha "JBoss Enterprise Application Platform 6.1+", que se encontra na pasta "Red Hat JBoss Middleware" e clique em next.</li>
                    			<li>Na janela seguinte, confirme se a opção marcada no menu dropdown será "Create new Runtime" e siga para a página de configuração.</li>
                    			<li>No campo "Home Directory", preencha com o caminho onde o jboss foi extraído.</li>
                    			<li>No campo de seleção da JRE, selecione a 1.7 que você possui instalada. Passe para próxima página e, então, finalize a instalação.</li>
                    			<li>Dentro da pasta da JAPI, você encontrará um arquivo "japiConfig.json". Copie-o para a pasta "standalone/configuration" encontrada no local de instalação do seu JBoss.</li>
                    			<li>Abra o arquivo que você acabou de copiar e modifique de acordo com as configurações do seu banco de dados.</li>
                    		</ul>
                    		<p>Ao fim da execução do passo-a-passo, você poderá visualizar seu novo servidor na aba "Servers" do Eclipse.</p>
                    		<h3>2: Importar os Projetos</h3>
                    		<p>Ao fazer o download da JAPI, você recebe quatro pastas ("assets", "common", "docs" e "modelo"), um arquivo "core.jar" e um arquivo "japiConfig.json".
                    		Utilizando a ferramenta de importação do eclipse, você deve importar as duas pastas como sendo dois projetos java.</p>
                    		<p>Segue o passo-a-passo:</p>
                    		<ul>
                    			<li>Clique em File -> Import...</li>
                    			<li>Na pasta General, Selecione "Existing Projects into Workspace".</li>
                    			<li>Na nova janela, selecione o caminho da pasta onde o conteudo baixado foi extraído. O eclipse encontrará, automaticamente, todos os projetos que ele pode importar a partir desta.</li>
                    			<li>Confirme que deseja importar os dois projetos encontrados e finalize.</li>
                    		</ul>
                    		<p>Feito isso, os quatro projetos estarão importados, mas ainda não estarão configurados.</p>
                    		<p>O projeto Assets será um projeto estático, e será tratado mais a frente</p>
                    		<p>O projeto Common, em específico, é um projeto que terá uma configuração diferente, já que será apenas um utilitário.</p>
                    		<p>É remoendável que recursos que serão utilizadas por todos os métodos (como por exemplo classes de constantes e templates velocity) sejam definidos no mesmo.</p>
                    		<p>O passo-a-passo para configuração do "Docs" e do "Modelo" seguem abaixo. O Common será tratado no item 6 desse passo-a-passo.
                    		<h3>3: Instalar as Facets</h3>
                    		<p>Clicando com o botão direito e selecionando Properties de cada um dos dois projetos, nós entraremos no menu de configuração que será utilizado a partir daqui. Os passos devem ser repetidos para cada projeto e para cada novo módulo que possa vir a ser criado.</p>
                    		<ul>
                    			<li>Selecionando, no menu lateral, a opção Project Facets, encontraremos uma tela que diz que o projeto ainda não é definido para esta configuração. Clique em "Convert to Faceted Form" e um novo menu de opções aparecerá.</li>
                    			<li>Nesse novo menu, você precisará selecionar duas opções: Java (certificando-se de colocar uma versão igual ou superior à 1.7) e Dynamic Web Module.</li>
                    		</ul>
                    		<h3>4: Configurar o Build Path</h3>
                    		<ul>
                    			<li>Ainda no menu de configurações, selecione a opção Java Build Path no menu lateral.</li>
                    			<li>Na aba Source, confirme que a pasta que se encontra definida como fonte é a "nome_do_projeto/src".</li>
                    			<li>Na aba Projects, adicione o projeto Common</li>
                    			<li>Na aba Libraries, devem constar: </li>
                    			<ul>
                    				<li>EAR Libraries (Encontrada no menu principal da janela de "Add Library").</li>
                    				<li>JRE System Library (Encontrada da mesma forma).</li>
                    				<li>JBoss Enterprise Application Platform 6.1 (Encontrada em Server Runtime -> Nome do seu servidor.)</li>
                    				<li>core.jar (baixado com a JAPI e encontrado pela guia "Add External JARs").</li>
                    			</ul>
                    		</ul>
                    		<h3>5: Configurar o deployment assembly</h3>
                    		<ul>
                    			<li>Vá agora para a opção Deployment Assembly, no menu lateral.</li>
                    			<li>Clique em "Add" e escolha "Java Build Path Entries" e então "core.jar".</li>
                    			<li>Para finalizar, adicione também o projeto "Common".</li>
                    		</ul>
                    		<h3>6: Configurando o Common e o Assets</h3>
                    		<p>Como o Common será um projeto de utilidades, cabe ao desenvolvedor escolher como o utilizará.</p>
                    		<p>Ele pode, por exemplo, ser um projeto Gradle ou Maven e gerenciar dependências da aplicação, ou mesmo ser um projeto que armazena recursos web (html, css e javascript) e se tornar um Dynamic Web Module.</p>
                    		<p>Porém, a configuração padrão do mesmo é a de UtilityModule, em que contenha apenas recursos a serem utilizados pelo Java nos demais módulos.</p>
                    		<p>Portanto, segue a configuração padrão do projeto:</p>
                    		<ul>
                    			<li>Project Facets</li>
                    			<ul>
                    				<li>Devem ser adicionadas as Facets "Java" e "Utility Module"</li>
                    			</ul>
                    			<li>Build Path</li>
                    			<ul>
                    				<li>A configuração é semelhante à do Build Path dos demais módulos, com a diferença de que a aba Projects deve ficar vazia.</li>
                    			</ul>
                    			<li>Deployment Assembly</li>
                    			<ul>
                    				<li>A configuração também é semelhante à dos demais projetos, não havendo necessidade de adicionar o prórprio projeto ao seu Deploym,ent Assembly</li>
                    				<li>Uma observação importante é que, caso o Common seja utilizado como gerenciador de dependênias, as suas bibliotecas de dependência devem ser adicionadas, também, ao Deployment Assembly. Isso garante que todos os projetos tenham acesso a elas.</li>
                    			</ul>
                    		</ul>
                    		<p>Já o Assets é um projeto unica e exclusivamente voltado para armazenamento de recursos web (html, css, javascript).</p>
                    		<p>A configuração dele segue abaixo:</p>
                    		<ul>
                    			<li>Project Facets
	                    			<ul>
	                    				<li>Devem ser adicionadas as Facets "Javascript" e "Static Web Module".</li>
	                    			</ul>
	                    		<li>Deployment Assembly</li>
	                    			<ul>
	                    				<li>Apenas a pasta WebContent deve estar presente.</li>
	                    			</ul>
                    		</ul>
                    		<h3>7: Adicionar os módulos ao JBoss e iniciar</h3>
                    		<ul>
                    			<li>Para finalizar, basta clicar com o botão direito sobre o seu servidor, na aba "Servers" do Eclipse.</li>
                    			<li>Escolha a opção "Add and Remove..." e adicione os módulos "Assets", "Docs" e "Modelo" a ela.</li>
                    			<li>Novamente com o botão direito no nome do servidor, clique em start.</li>
                    			<li>Acesse <a href = "http://localhost:8080/docs">esse link</a> e veja o seu servidor funcionando.</li>
                    		</ul>
                    	</div>
                    	<hr>
                    	<div id = "modulos">
                    		<h1>Módulos</h1>
                    		<p>Botar um texto bonito aqui explicando a filosofia dos modulos, que eles são independentes, bla bla bla</p>
                    		<hr>
                    		<h3 id="primeiroModulo">Criando seu primeiro módulo</h3>
                    		<p>Para começarmos a trabalhar com a Framework, devemos criar nossa primeira API. Para isso, devemos criar um novo projeto (ou utilizar o projeto modelo).</p>
                    		<p>Além disso, devemos alterar o método DocsConfig, encontrado na Classe JapiDocs em br.planejamento.gov.api.docs.app, dentro do projeto Docs. Deve ser adicionado à array o nome de nosso novo projeto, para que ele seja inserido no menu Documentação.</p>
                    		<p>A configuração de nosso novo projeto é idêntica a do Docs, que pode ser revista <a href="#configurando">aqui</a></p>
                    		<p>O projeto deve contar com quatro packages, descritos abaixo:
                    		<ul>
                    			<li>
                    				<h5>module</h5>
                    				<p>Contém apenas uma classe, que deve ser muito semelhante ao modelo:</p>
                    				<pre class="brush: js;">package br.gov.planejamento.api.modelo.module;

import javax.ws.rs.ApplicationPath;
import javax.ws.rs.GET;
import javax.ws.rs.Path;

@ApplicationPath("/")
public class ModeloModule extends Module {
	
	/*
	 * Dentro da classe que define o módulo, devemos configurar o sistema de Documentação.
	 * A documentação gerada pela JAPI utiliza uma representação JSON (swagger) que interpreta o código feito nos demais packages
	 * e mapeia, para o usuário, as possibilidades de request e de resposta do servidor.
	 *
	 * Para que esse JSON seja gerado, a configuração abaixo é necessária.
	 *
	 * No Path definimos o endereço por onde o json será encontrado. No exemplo dado, ele seria acessível por "http://localhost:8080/modelo/v1/modelodocs".
	 *Esse é o padrão de endereço para documentação.
	 *
	 * O método extractDocumentation lê todo o arquivo que é apontado (no caso, a camada request do módulo modelo) e, a partir das annotations, gera o json.
	 */
	@GET
	@Path("/v1/modelodocs")
	public String getDocs() {
		return extractDocumentation("br.gov.planejamento.api.modelo.request");
	}
}</pre>
									<p>Essa classe é fundamental para o funcionamento e mapeamento da sua API.</p>
                    			</li>
                    			<li>request</li>
                    			<li>resource</li>
                    			<li>service</li>
                    		</ul>
                    		<p>O conteúdo dos pacotes será explicado na próxima seção.</p>
                    	</div>
                    	<hr>
                    	<div id = "camadas">
                    		<h1>As Camadas</h1>
                    		<p>Botar um texto bonito aqui, explicando a filosofia por trás da abstração, se quiserem. Eu por mim deixo em branco mesmo rsrsrs</p>
                    		<hr>
                    		<h3 id="request">Request</h3>
                    		<p>A camada de Request é a responsável por tratar a requisição feita pelo usuário.</p>
                    		<p>Isso significa que, ao digitar uma url do tipo "http://localhost:8080/modulo/pagina", o sistema saberá, a partir da camada de request, quais ações devem ser tomadas e quais listagens devem ser exibidas.</p>
                    		<p>O conteúdo exemplificado de uma classe de request segue abaixo:</p>
                    		<pre class="brush: js;">@Path("/") //No caso, a raíz do módulo que estamos utilizando. Seria "http://localhost:8080/modelo", por padrão.
public class ModeloRequest {

	private ModeloService mService = new ModeloService();
	
	/*
	 * A partir daqui começamos a desenvolver nossos métodos da request.
	 *
	 * Cada método é uma consulta (por isso é assinalado com a Annotation @GET) que é feita ao banco de dados.
	 *
	 * Ao ler esse método, a documentação atribuirá a ele no nome definido em @Name. Portanto, é necessário que o atributo seja preenchido.
	 *
	 * Em @Path, devemos preencher o caminho a ser digitado, a partir da API, para chegarmos ao método da request.
	 * Por exemplo, no caso, acessaríamos o método abaixo ao digitar http://localhost:8080/modelo/v1/modelos
	 *
	 * @Returns define o retorno da Request. Será utilizado na documentação automática.
	 * Essa annotation pode ter um segundo parâmtro "isList=true", caso a consulta retorne uma lista de resultados.
	 * O padrão é "isList=false" que retorna um resultado único
	 *
	 * @Description define, na docuemntação, qual será a explicação daquele método.
	 *
	 * Todas as annotations são obrigatórias para a geração de documentação, embora apenas as duas primeiras sejam necessárias 
	 * para o funcionamento do Request.
	 */
	@GET
	@Name("modelos")
	@Path("v1/modelos")
	@Returns(ModeloResource.class, isList=true)
	@Description("Lista de modelos")
	/*
	 * O método abaixo tem como retorno uma Response, que contém do que uma lista de Resources (explicados mais a frente).
	 *
	 * Os paramêtros do método são as informações que ele pode receber por GET. No caso, a URL poderia conter os parâmetros
	 * "inteiro" e "str".
	 *
	 * Esses parâmetros serão usados mais a frente para realizarmos filtros dentro do banco de dados.
	 *
	 * A annotation "@Parameter" representa que aquelas informações são utilizadas pela documentação da API.
	 *
	 * O campo "name" representa o nome do campo que aparecerá na documentação, "required" define se o campo é obrigatório
	 * ou não e "description" é uma breve descrição do que o campo representa, no sistema.
	 *
	 * O lançamento da JAPIException é obrigatório, já que ela encapsula todas as exceptions do Java e as trata, além de 
	 * exceptions próprias da JAPI.
	 */
	public Response modelos( 
				@Parameter(name = "inteiro", required = false, description = "Um inteiro") int inteiro,
				@Parameter(name = "str", required = false, description = "Uma sting") String str			
			) throws JapiException  {
		
		/*
		 * O tipo Session contém todas as informações da Request feita pelo usuário e é preenchido internamente pela API. 
		 *
		 * Para descobrirmos, por exemplo, qual a URL e os parâmetros passados pelo usuário, devemos consultar esse tipo.
		 */
		RequestContext context = RequestContext.getContext(); 
		
		/*
		 * O método addFilter descrito abaixo é o responsável por adicionar na Session os filtros que serão feitos no banco
		 * de dados.
		 *
		 * os argumentos são do tipo Filter, e a API reconhece três possiveis como padrão, podendo ser criados novos pelo
		 * usuário.
		 *
		 * Os três existentes são: 
		 *
		 * EqualFilter, que realiza uma busca por elementos estritamente iguais no banco de dados;
		 * LikeFilter, que realiza uma busca por elementos que contenham o trecho passado;
		 * CaseInsensitiveLikeFilter, que é semelhante ao LikeFilter, mas não diferencia maiúsculas e minúsculas do 
		 * argumento.
		 *
		 * A declaração dos filtros utiliza dois argumentos: tipo e databaseAlias.
		 *
		 * O tipo é opcional, e define a comparação que ocorrerá. Por exemplo, comparação entre Inteiros, Booleanos, 
		 * Strings...
		 *
		 * O DatabaseAlias é um tipo próprio da JAPI que relaciona um argumento passado pela URL a uma coluna do banco de 
		 * dados ao qual ele deverá ser comparado.
		 *
		 * Para isso, a constução dele recebe dois argumentos: o nome da coluna no banco de dados e o nome da variável 
		 * utilizada no método
		 *
		 * Caso a variável tenha o mesmo nome que a coluna no banco, o segundo argumento é desnecessário. 
		 */
		context.addFilter(
				new EqualFilter(Integer.class, new DatabaseAlias("int_inteiro", "inteiro")),
				new CaseInsensitiveLikeFilter(new DatabaseAlias("str"))
		);
		
		/*
		* É invocado o método do Service (explicado mais a frente) que realizará a busca no banco de dados. e retornará a 
		* Response contendo os elementos filtrados.
		*/
		Response response = mService.all();
		return response;
	}
}</pre> 
                    		<hr>
                    		<h3 id="resource">Resource</h3>
                    		<p>Para a API, a camada Resource representa o Objeto java que é formado a partir dos dados recebidos do Banco.</p>
                    		<p>É a camada fundamental que trata a resposta, para o usuário, da Resquest que ele fez.</p>
                    		<p>O tipo Response, visto como o retorno de uma Request, contem uma lista de Objetos Resource, que é então exibida para o usuário.</p>
                    		<p>Para entendermos melhor como ele funciona, segue o trecho do código:</p>
                    		<pre class = "brush:js">/*É necessário que a Classe do seu Resource extenda a Classe abstrata Resource, da JAPI.
 * Essa classe contem métodos que são utilizados para exibir as informações do Resource para o usuário.
 */
public class ModeloResource extends Resource {

	private int inteiro;
	private String str;
	
	public ModeloResource() {
		super();
	}
	
	
	/*
	 * Construtor utilizado para gerar um objeto do Resource a partir de uma linha do BD. Automatiza o mapeamento
	 * dos parâmetros e facilita a adaptaçao dos campos pelo desenvolvedor, uma vez que ele não precisa modificar o 
	 * service sempre que houver uma mudança no resource, precisando apenas modificar esse construtor.
	 *
	 * O método get, do tipo Datarow, recebe como argumento o nome da coluna daquele campo no banco de dados. 
	 */
	public ModeloResource(DataRow modelo) {
		super();
		this.inteiro = modelo.get("inteiro");
		this.str = modelo.get("str");
	}
	
	/* A partir daqui temos os Getters and Setters das propriedades do Resource.
	 *
	 * O único cuidado que precisamos ter é que o retorno dos Getters deve ser, sempre, uma Property.
	 *
	 * Property é um tipo primitivo da Framework que representa um campo que deve vir a ser exibido para o usuário.
	 *
	 * O contrutor da Property recebe dois argumentos: Uma String que representa o nome da Property (que será visto pelo
	 * usuário) e o valor da property, que nada mais é do que a variável que, normalemnte, seria retornada pelo Getter.
	 *
	 * Além disso, a Property pode conter um link para alguma página externa, e para isso é usado o tipo LinkProperty,
	 * que recebe em seu construtor, além do nome e do valor, uma String que representa a "href"" do link e uma outra que
	 * representa a "rel".
	 *
	 *A utilização de LinkProperties é fundamental para relacionar os módulos entre si e integrar a API.
	 */ 
	public Property getInteiro() {
		return new LinkProperty('Um inteiro', 
        'URL para outro módulo ou outra área do mesmo módulo', 
		inteiro, 
		'Nome do módulo ou área relacionada');
	}

	public void setInteiro(int inteiro) {
		this.inteiro = inteiro;
	}

	public Property getStr() {
		return new Property('Uma String', str);
	}

	public void setStr(String str) {
		this.str = str;
	}

	/*
	 * SelfLink é o link que aponta para o seu Resource. 
	 *
	 * Ao realizar uma consulta, a resposta virá em formato de Response, que é uma lista de Resources.
	 * 
	 * Nessa lista é possível acessar a página exclusiva de um desses Resources clicando sobre o SelfLink do mesmo.
	 *
	 * O contrutor do SelfLink recebe dois parâmetros: Uma string "href", que representa a url para o mesmo e uma string 
	 * "title" que define o nome de exibição do link.
	 */
	@Override
	public SelfLink getSelfLink() {
		return new SelfLink('url para o meu resource', 'nome do meu resource');
	}
	
	/*
	 * LINKS
	 * 
	 * Além do SelfLink, um Resource pode possuir outros métodos que retornem links, fazendo referências a
	 * ResourceLists. Todos os métodos que retornem Link serão automaticamente chamados
	 * em todos os formatos de request.
	 * Caso um método não deva ser automaticamente chamado, deve ser anotado com @Ignore ou
	 * @HTMLIgnore, @JSONIgnore, @XMLIgnore, @CSVIgnore caso deva ser ignorado somente em formatos específicos.
	 * 
	 * Uma observação importante é que estes métodos só devem ser usados para retornar Links genéricos,
	 * que não estejam associados a nenhuma propriedade do Resource. Caso deseje inserir um link associado
	 * a uma Property, como geralmente usado em chaves estrangeiras, você deve criar um método que retorne LinkProperty,
	 * como explicado na seção acima
	 */
	 
	 @Description("")
	public Link getLinkParaConsultasExternas()
	{
		return new Link('url para a consulta', 'título da consulta', 'rel para a consulta');
	}

}
                    		</pre>
                    		<hr>
                    		<h3 id="service">Service</h3>
                    		<p>É a camada intermediária da API. A partir da Request, o Service é chamado com a função de gerar uma Resposta a partor do que foi pedido.</p>
                    		<p>Para isso, essa camada faz a conexão com o banco de dados, executando a query específica e obtendo os resultados desejados em forma de uma Response.</p>
                    		<p>Para entendermos melhor, segue o código:</p>
                    		<pre class = "brush: js">/* 
 * A sua classe service deve extender a classe abstrata Service, que contém as lógicas de conexão com o Banco de dados e definicão de queries.
 */
public class ModeloService extends Service {

	/*
	 * O método getServiceConfiguration é o responsável por configurar a conexão do seu Service com o Banco de dados a ele relacionado.
	 *
	 * Como cada Service será relacionado a uma tabela do banco de dados, é a partir deste método que definimos qual tabela é essa, a qual schema ela pertence e quais os campo dela nosso service utilizará para montar a Response.
	 *
	 * As queries criadas pelo Service (classe abstrata) utilizam as informações inseridas aqui.
	 */
	@Override
	protected ServiceConfiguration getServiceConfiguration() {
		ServiceConfiguration configs = new ServiceConfiguration();
		configs.setSchema("schema"); //Nome do schema postgres ao qual estamos conectando. Lembrando que a configuração do banco de dados em si é feita no JAPIConfig.json, como descrito no primeiro passo da seção "Configurando o ambiente".
		configs.setTable("table"); //Nome da table ou view de onde serão extraídas as informações.
		configs.setResponseFields("inteiro", "str"); //Campos que serão recebidos como resposta da query, e consequentemente moldarão a Response.
        configs.setValidOrderByValues("uasg","nome_modalidade","numero_aviso", "data_abertura_proposta"); // Possibilidades de ordenação via url, utilizando o padrão 'order_by= '

		return configs;
	}

	/*
	 * Método que ativa toda a lógica de conexão com o Banco de dados e retorno de resultados.
	 *
	 * O desenvolvedor precisa apenas chamar o método getAllFiltered() da classe pai, que fará tudo automaticamente utilizando os filtos que foram inseridos na Session pelo Request e as configurações feitas no getServiceConfiguration().
	 * 
	 * Feito isso, transforma-se as linhas recebidas em um Response de retorno.
	 */
	public Response all() throws JapiException{
			DatabaseData dados = getAllFiltered();
            Response retorno = new Response(dados.getCount());
        
            for(DataRow modelo : dados) {
                retorno.add(new ModeloResource(modelo));
            };

            return retorno
	}

}
                    		</pre>
                    	</div>
                    </div>
                </div>
            </div>
        </div>
        <!-- /#page-content-wrapper -->

    </div>
    <!-- /#wrapper -->

    <!-- jQuery -->
    <script src="js/jquery.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="js/bootstrap.min.js"></script>

    <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    
    <script src="http://alexgorbatchev.com/pub/sh/current/scripts/shCore.js" type="text/javascript"></script>
    <script src="http://alexgorbatchev.com/pub/sh/current/scripts/shBrushJScript.js" type="text/javascript"></script>
	<script src="http://alexgorbatchev.com/pub/sh/current/scripts/shAutoloader.js" type="text/javascript"></script>
	<script type="text/javascript">
	     SyntaxHighlighter.all()
	</script>
</body>

</html>
